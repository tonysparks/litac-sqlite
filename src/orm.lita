import "std/string/builder"
import "std/string/buffer"
import "std/string"
import "std/array"
import "std/mem"
import "std/libc"

import "db"

public struct Team {
    id: i64
    name: String
    city: String
    state: String
}

public func (this: *Team) getSqlSelectOneById() : String {
    return
        $"""
        SELECT
            t.id,
            t.name,
            t.city,
            t.state
        FROM team t
        WHERE t.id = :ID
        """
}

public func (this: *Team) getSqlSelect() : String {
    return
        $"""
        SELECT
            t.id,
            t.name,
            t.city,
            t.state
        FROM team t
        """
}
/*
public func (this: *Team) bindName(
    stmt: *SqlStatement,
    id: i64,
    fromIndex: i32
) : i32 {
    stmt.bindString(fromIndex += 1, id)
    return fromIndex
}*/

public func (this: *Team) fromResultSet(
    resultSet: *SqlResultSet,
    fromIndex: i32,
    allocator: *const Allocator
) : i32 {
    this.id = resultSet.columnInt64(fromIndex += 1)

    var sb = StringBuilderInit(1024, allocator)
    var len = 0

    len = sb.append("%s", resultSet.columnString(fromIndex += 1))
    this.name = sb.substring(sb.length - len, sb.length)

    len = sb.append("%s", resultSet.columnString(fromIndex += 1))
    this.city = sb.substring(sb.length - len, sb.length)

    len = sb.append("%s", resultSet.columnString(fromIndex += 1))
    this.state = sb.substring(sb.length - len, sb.length)

    return fromIndex
}

public func (this: *Team) bindId(
    stmt: *SqlStatement,
    id: i64,
    fromIndex: i32
) : i32 {
    stmt.bindInt64(fromIndex += 1, id)
    return fromIndex
}


// ---------------------------------------------------------
// ORM API
// ---------------------------------------------------------

public func (this: *SqlConnection) queryMany<T>(
    result: *Array<T>,
    where: String,
    $...
) : SqlResult {

    if (this.hasError()) return this.error

    // TODO: Cache these prepared statements per entity type
    var stmt = SqlStatement{}
    defer stmt.close()

    var sb = StringBuilderInit(1024, this.allocator)

    var resultType = T{}
    var select = resultType.getSqlSelect()
    sb.append("%.*s WHERE %.*s",
        select.length, select.buffer,
        where.length, where.buffer
    )
printf("Query: %s\n", sb.cStr())
    this.prepare(
        &stmt,
        sb.toString()
    )

    var index = 1

    var list: va_list
    va_start(list, where)
    var vargs = va_arg<NativeVararg>(list)
    for(var i = 0; i < vargs.numberOfArgs; i+=1) {
        var typeid = vargs.args[i]
        switch(typeid) {
            case typeof(:bool):
            case typeof(:i8):
            case typeof(:u8):
            case typeof(:i16):
            case typeof(:u16):
            case typeof(:u32):
            case typeof(:i32): {
                stmt.bindInt32(index, va_arg<i32>(list))
                break
            }
            case typeof(:usize):
            case typeof(:u64):
            case typeof(:i64): {
                stmt.bindInt64(index, va_arg<i64>(list))
                break
            }
            case typeof(:f32):
            case typeof(:f64): {
                stmt.bindFloat64(index, va_arg<f64>(list))
                break
            }
            case typeof(:String): {
                var str = va_arg<String>(list)
                stmt.bindString(index, str)
                printf("Binding: %.*s\n", str.length, str.buffer)
                break
            }
            case typeof(:*const char):
            case typeof(""): {
                var str = va_arg<*const char>(list)
                stmt.bindText(index, str, strlen(str))
                printf("Binding: %s\n", str)
                break
            }
            default: {
                var msg = StringBuilderInit(256, this.allocator)
                msg.append("Unsupported parameter type: %lu", typeid)
                this.error = SqlResult {
                    .type = SqlResultType.ERROR,
                    .description = msg.toString()
                }
                return this.error
            }
            index += 1
        }
    }

    var resultSet = SqlResultSet{}
    stmt.execute(&resultSet)

    result.init(32 /* TODO */, this.allocator)

    while(resultSet.hasNext()) {
        result.add(T{})

        var row = result.lastPtr()
        row.fromResultSet(&resultSet, -1, this.allocator)
    }

    stmt.reset()

    return this.error
}

public func (this: *SqlConnection) queryOneById<T, ID>(
    result: *T,
    id: ID
) : SqlResult {
    // TODO: Cache these prepared statements per entity type
    var stmt = SqlStatement{}
    defer stmt.close()

    this.prepare(
        &stmt,
        result.getSqlSelectOneById()
    )

    result.bindId(&stmt, id, 0)

    var resultSet = SqlResultSet{}
    stmt.execute(&resultSet)

    if (!resultSet.hasNext()) {
        return SqlResult {
            .type = SqlResultType.OK,
            .category = SqlResultCategory.EMPTY_RESULTS,
            .description = $"Empty result"
        }
    }

    resultSet.next()
    result.fromResultSet(&resultSet, -1, this.allocator)

    return this.error
}